SUBROUTINE DR_HOOK_UTIL(CDNAME,KCASE,PKEY,CDFILENAME,KSIZEINFO)
USE PARKIND1  ,ONLY : JPIM     ,JPRB
USE YOMHOOK,ONLY : LHOOK
USE YOMOML,ONLY : OML_MAX_THREADS,OML_MY_THREAD,OML_INIT
USE ECSORT, ONLY : SORTING_METHOD
USE MPL_INIT_MOD
USE MPL_ARG_MOD
IMPLICIT NONE
CHARACTER(LEN=*),INTENT(IN) :: CDNAME,CDFILENAME
INTEGER(KIND=JPIM),INTENT(IN) :: KCASE,KSIZEINFO
REAL(KIND=JPRB),INTENT(INOUT) :: PKEY
#ifdef RS6K
INTEGER(KIND=JPIM) :: INEWMASK, IOLDMASK, UMASK
#endif
#ifdef CRAYXT
INTEGER(KIND=JPIM) :: IRET, SETVBUF3F
#endif
LOGICAL,SAVE :: LL_FIRST_TIME = .TRUE.
CHARACTER(LEN=512) :: CLENV
INTEGER(KIND=JPIM) INUMTIDS, IMYTID
LOGICAL :: LLMPI

! -----------------------------------------------------------------

IF (.NOT.LHOOK) RETURN
IF (LL_FIRST_TIME) THEN
  LL_FIRST_TIME = .FALSE.
#ifdef CRAYXT
  IRET = SETVBUF3F(0, 1, 0) ! Set unit#0 into line-buffering mode to avoid messy output
#endif
  CALL OML_INIT()
  CALL EC_GETENV('DR_HOOK_NOT_MPI',CLENV)
  IF (CLENV == ' ' .OR. CLENV == '0' .OR. &
    & CLENV == 'false' .OR. CLENV == 'FALSE') THEN
    LLMPI=.TRUE.
    CALL MPL_INIT(LDINFO=.FALSE.) ! Do not produce any output
  ENDIF
  CALL EC_GETENV('DR_HOOK',CLENV)
  IF (CLENV == ' ' .OR. CLENV == '0' .OR. &
    & CLENV == 'false' .OR. CLENV == 'FALSE') THEN
    LHOOK = .FALSE.
    CALL C_DRHOOK_SET_LHOOK(0)
  ENDIF
  IF (LLMPI) THEN
    CALL MPL_GETARG(0, CLENV)  ! Get executable name & also propagate args
  ELSE
    CALL GETARG(0, CLENV)
  ENDIF
! A way to override the default ECSORT'ing method (export EC_SORTING_METHOD=[<number>|<string>])
! For example: export EC_SORTING_METHOD=radix
! See more ifsaux/module/ecsort.F90
  CALL SORTING_METHOD()
  IF (.not.LHOOK) RETURN
  
  INUMTIDS = OML_MAX_THREADS()
  CALL C_DRHOOK_INIT(CLENV, INUMTIDS)
ENDIF
IMYTID = OML_MY_THREAD()
IF (KCASE == 0) THEN
  CALL C_DRHOOK_START(CDNAME, IMYTID, PKEY, CDFILENAME, KSIZEINFO)
ELSE IF (KCASE == 1) THEN
  CALL C_DRHOOK_END  (CDNAME, IMYTID, PKEY, CDFILENAME, KSIZEINFO)
ENDIF

END SUBROUTINE DR_HOOK_UTIL
